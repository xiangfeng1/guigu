1、HashMap和Hashtable的底层实现：
（1）Hashtable：
    简单说：哈希表，
    详细说：由数组+链表构成的哈希表
（2）HashMap：
     简单说：哈希表，
     详细说：JDK8之前，由数组+链表构成的哈希表
     详细说：JDK8之后，由数组+链表+红黑树构成的哈希表

2、哈希表中为什么要选择“数组”结构？
因为数组的优点：可以根据“下标”快速地定位到某个元素。

3、哈希表是如何利用数组存储元素的？和普通的数组有什么不同？
普通的数组：元素是从头一个一个连续存储的
哈希表中的数组：元素是散列存储

4、如何把元素“散列”到数组中？假设数组名是table
散列的方案之一：
    hashCode值 % table.length 的结果范围[0, table.length-1]
    [index] = hashCode值 % table.length
散列的方案之二：（源码选择这种）
    hashCode值 & table.length-1  的结果范围[0, table.length-1]
    [index] = hashCode值 & （table.length - 1）

 假设：table.length=16, table.length-1=15
   hashCode值二进制值：      xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
   table.length-1的二进制值：00000000 00000000 00000000 00001111
   &-----------------------------------------------------------
                           00000000 00000000 00000000 0000xxxx
                           00000000 00000000 00000000 00000000  0
                           00000000 00000000 00000000 00000001  1
                           00000000 00000000 00000000 00000010  2
                           00000000 00000000 00000000 00000011  3
                           ...
                           00000000 00000000 00000000 00001111  15


3、哈希表中为什么要选择“链表”结构？
因为①“不同”的对象的hashCode值可能相同，
或者②就算两个对象的hashCode值不同，但是[index] = hashCode值 & （table.length - 1）
例如：
            System.out.println(31 & 15);//15
            System.out.println(63 & 15);//15
这两种情况称为哈希冲突，即导致不同的对象被散列到了相同的table[index]位置。
一个table[index]无法存储多个对象，所以必须把这多个对象使用“链表”连接起来，
table[index]存储的是链表的“头结点”。

4、为什么HashMap在JDK8之后，又要引入红黑树结构呢？
因为随着元素数量增多，链表的长度会出现很长的情况，
而HashMap是要求元素(key,value)的key不可重复，
就需要与链表中的所有（key,value)的key全部比较一遍，确定不重复才能添加，
如果要删除的话，也要全部查找一下，确定删除目标。
这就导致增、删、查的效率降低了。

红黑树是一种特殊的平衡二叉树，天然的支持二分查找，可以大大地提高查询效率。

5、为什么“链表”与“红黑树”共存呢？
当“链表”没有长的时候，链表的效率反而比“红黑树”更高一些，因为红黑树太复杂了。
即哈希表中会根据“链表”的长度来确定什么时候用“链表”什么时候用“红黑树”。

6、数组的长度是多少呢？默认选择16
 假设：table.length=16, table.length-1=15
   hashCode值二进制值：      xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
   table.length-1的二进制值：00000000 00000000 00000000 00001111
   &-----------------------------------------------------------
                           00000000 00000000 00000000 0000xxxx
                           00000000 00000000 00000000 00000000  0
                           00000000 00000000 00000000 00000001  1
                           00000000 00000000 00000000 00000010  2
                           00000000 00000000 00000000 00000011  3
                           ...
                           00000000 00000000 00000000 00001111  15

 假设：table.length=10, table.length-1=9
   hashCode值二进制值：      xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
   table.length-1的二进制值：00000000 00000000 00000000 00001001
   &-----------------------------------------------------------
                           00000000 00000000 00000000 0000x00x
                           00000000 00000000 00000000 00000000  0
                           00000000 00000000 00000000 00000001  1
                           00000000 00000000 00000000 00001000  8
                           00000000 00000000 00000000 00001001  9
 如果数组的长度选择10，散列的[index]位置可选性只有4种，
 如果数组的长度选择16，散列的[index]位置可选性有16种，即每一个位置都可能。


7、数组的长度会一直16吗？即数组会扩容吗？
随着元素(key,value)越来越多，那么数组一定要扩容的，否则就会导致哈希冲突非常严重，效率大大降低。

8、数组的扩容机制是什么？
数组的长度如果一直保持是2的n次方，那么数组的每一个[index]才都有可能被用上，
所以数组的扩容机制是 2倍扩容。

9、数组扩容时，哈希表中已有的(key,value)会需要重新计算存储位置吗？
    hashCode值 & table.length-1  的结果范围[0, table.length-1]
    [index] = hashCode值 & （table.length - 1）

答案：必须重新计算

     hashCode值二进制值：      xxxxxxxx xxxxxxxx xxxxxxxx xxx?xxxx
     table.length-1的二进制值：00000000 00000000 00000000 00001111  扩容前
     table.length-1的二进制值：00000000 00000000 00000000 00011111  扩容后
     &-----------------------------------------------------------
                             00000000 00000000 00000000 0000xxxx 扩容前
                             00000000 00000000 00000000 000?xxxx 扩容后

     大部分元素不需要移动，只有哪些hashCode在?位置是1的，才需要移动位置。
     而且移动的位置也有规律。

10、什么时候扩容呢？
第一种情况：
int size; 元素个数
int threshold; 阈值  当size>=threshold就会扩容
final float loadFactor; 加载因子
static final float DEFAULT_LOAD_FACTOR = 0.75f;

    threshold = table.length * loadFactor;

假设：table.length=16,     threshold=16*0.75=12

第二种情况：
当单个链表的长度达到8个，但是数组的长度没有达到64，继续往这个链表增加元素，就会导致数组扩容。

11、链表多长会考虑升级为红黑树？
int TREEIFY_THRESHOLD = 8; 树化阈值，从链表开始考虑转为红黑树的临界值
                    即链表的长度达到8个时候，会考虑用红黑树
int MIN_TREEIFY_CAPACITY = 64;  数组的最小树化容量
                    即出现红黑树的前提，数组的长度达到64

如果数组的长度<64，但是链表的长度>=8，怎么办？
此时会先对数组进行扩容。因为扩容可能会让原来集中在同一个table[index]位置的元素，
重新计算[index]位置后，分散开来。

总结：
（1）数组的长度达到64
（2）单个链表长度达到8，才会从链表升级为红黑树

12、红黑树会转回链表吗？如果会，什么时候转呢？
答案：会

int UNTREEIFY_THRESHOLD = 6; 反树化阈值，当红黑树的结点数量<=6个时候，就要考虑转为链表

什么操作会触发它从红黑树转为链表？
（1）一直删除元素，当删除出现 红黑树的根结点的左左出现null，或根结点的左或右结点出现null,继续删除就会出现反树化
（2）当红黑树的结点数量<=6时，继续添加，触发了数组的扩容，此时会把红黑树转为链表。

13、计算[index]时候是用(key,value)的key的原始hashCode值计算的吗？
答案：不是

   会对key的hashCode值，再次进行一次hash运算。
   JDK7和JDK8对hashCode值的再次处理算法不同，但是目的是相同的。
   目的是为了让hashCode值的二进制高位也发挥作用，尽量把(key,value)散列到table的不同位置。

   JDK8为例：
       static final int hash(Object key) {
           int h;
           return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
       }

14、key为null键值对，在table数组中存在哪里？
答案：[0]

15、(key,value)存入map中后，key对象是否可以修改？
结论：不能修改

实际开发中，一般都用不可变对象作为key，例如：String,Integer等。
或者自己定义的类作为key的话，相关属性建议用final修饰。



